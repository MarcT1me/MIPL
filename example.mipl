from mipl.core import *__variables__, *__functions__
// импорт глобального поля переменных и функций а потом его как бы раскрытие
// иначе обращение выглядит так: `__variables__.some` а в коде вот так: `__variables__.__variables__.some`

// использование аргументов - переменных инициализирующихся при создании объекта mip
#miparg const uint USE_CODE
#miparg const uint PRINTING
#miparg const uint CROSSHAIR_XY_SIZE

// аналог uniform из GLSL - переменные для передачи в программу через API интерпретатора
linked buffer uint crosshairPyxels[CROSSHAIR_XY_SIZE]

// именованный блок кода \ словарь. Через ссылку можно получить доступ ко всем переменным в его локальном поле видимости
debug {
    var variable = 5
    #debug // в случе если запущено в релизе, то тупо снесёт блок
    <cast uint8>('crosshairPyxels->buffer.__type__)
    // каст типа данных в буфере
    // каст создаёт новое значение и как бы возвращает его с изменениями,
    // но передача ссылки заставляет его создать туже ссылку и изменить исходную переменную
    println(var.latest())  // `(int, "variable", 5)`
    #define
}


class InventoryCell {  // создание класса
    struct InventoryCell {  // классы тут создаются через структуры (которые работают и отдельно)
        // просто создание переменных
        uint8 num = 0
        uint8 storedId
    }

    uint8 index  // переменные указанные вне структуры - статичные поля

    void init(this, inout uint8 storedId) {  // инициализатор, выглядит как в Python но работает через вызов метода
        // в качестве второго аргумента используется ссылка на внешнюю переменную
        this.num = 64  // изначально имеем структуру this указанную выше, но имеем к ней доступ через `this`
        this.storedId = storedId  // ссылка указывалась бы как `'`, но так ка я указал идентификатор аргумент - не нужен
        this.index = index  // ОШИБКА ибо его нету в структуре, но есть вариант и с игнорированием, один хрен не верно
        InventoryCell.index++  // доступ к статичным элементам получаем через имя класса, через this спорно
    }

    void moveTwin(this, InventoryCell otherCell) {  // простой метод
        with link : (this | otherCell) {  // для упрощения указываю в условии что использую 2 переменные как связанные
            this.num, otherCell.num = otherCell.num, this.num  // тогда выходит, что я попросту поменяю ссылки местами
        }
    }
}


int getCode(uint s, int i, int j = 1) {  // функция с возвращаемым типом int
    return s - (i + j)  // простейшие скобки и т.д.
}


void main() {
    /*
    Точка входа в программу интерфейса
    Функции создаются как в С. Типы могут быть любыми `VAR_TYPE` кроме numeric или `void` - эксклюзив для функций
    */

    // обращение к всем объектам в сцене и изъятие игрока
    if __actors__ -> player.alive | (interface.flags & USE_CODE) {  // вид условий
        // к стати стрелочки означают преобразование либо ссылки, либо переменной из Python в MIPL
        // преобразование по условию: если этот кейворд из питона - преобразую и выдаю ссылку иначе выдаю ссылку
        surface chs = surface.init(crosshairPyxels) // инициализация класса
        chs.pos = vec2(0)  // перезапись
        interface.add(chs)  // использование методов. К стати из базовой переменной, как gl_FragCoord или gl_FragColor
    }

    #if PRINTING  // мета-код - остаётся в итоге только если `PRINTING` положительный
    numeric code = getCode(7, 1, 1)
    println(code - debug.variable)
    #define
}
